# 10. 활동성을 최대로  높이기
- 10.1 데드락
    - 10.1.1 락 순서에 의한 데드락
    - 10.1.2 동적인 락 순서에 의한 데드락
    - 10.1.3 객체 간의 데드락
    - 10.1.4 오픈 호출
    - 10.1.5 리소스 데드락
- 10.2 데드락 방지 및 원인 추적
    - 10.2.1 락의 시간 제한
    - 10.2.2 스레드 덤프를 활용한 데드락 분석
- 10.3 그 밖의 활동성 문제점
    - 10.3.1 소모 (Starvation)
    - 10.3.2 형편 없는 응답성
    - 10.3.3 라이브락

## 데드락이란?
다음의 네가지 조건을 모두 만족할 때 데드락이 발생한다.

`1. 상호 배제(Mutual Exclusion)`
- 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

`2. 점유 대기 (Hold and Wait)`
- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
- 즉, 이미 자원을 사용중인데, 다른 프로세스가 사용중인 자원을 사용하기 위해 대기하고 있는 상태의 프로세스가 존재해야 한다.

`3. 비선점 (No preemption)`
- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

`4. 순환 대기 (Circular wait)`
- 프로세스 **P0** 는 리소스 **R0** 를 점유하고 리소스 **R1** 을 요청
- 프로세스 **P1** 는 리소스 **R1** 을 점유하고 리소스 **R0** 을 요청
![resource_deadlock](/img/ch10_process_resource_diagram.svg)

## 10.1.1 락 순서에 의한 데드락
- Thread A: Left Lock -> Right Lock -> Waiting
- Thread B: Right Lock -> Left Lock -> Waiting
## 10.1.2 동적인 락 순서에 의한 데드락
```java
public method transfer(Account source, Account target, int amount) {
    synchronized (A) {
        synchronized (B) {
            if (A.getBalance() >= amount) {
                A.debit(amount);
                B.credit(amount);
            }
        }
    }
}
```
**문제 상황**
- A -> B 5000원 송금
- B -> A 3000원 송금
 
**해결 방법**
1. System.identityHashCode()를 이용한 락 순서 결정
2. Tie-breaking 을 위한 별도의 락 사용

## 10.1.3 객체 간의 데드락
- 객체 A의 synchronized 메서드가 객체 B의 synchronized 메서드를 호출
- 객체 B의 synchronized 메서드가 객체 A의 synchronized 메서드를 호출

**해결 방법**
- 락을 전혀 확보하지 않은 상태에서 메서드를 호출하는 오픈 호출을 이용하자
- synchronized 메서드를 사용하지 말고 critical section 을 synchronized 블록으로 감싸자
## 10.1.5 리소스 데드락
- Thread A: A DB Connection -> B DB Connection -> Waiting
- Thread B: B DB Connection -> A DB Connection -> Waiting

### 예제 Database Connection Pool 데드락
![connection_pool_deadlock](/img/ch10_connection_pool_deadlock.svg)

## 10.2.1 락의 시간 제한
- 암묵적락인 synchronized 는 시간 제한을 설정할 수 없다.
- 명시적락인 ReentrantLock 은 시간 제한을 설정할 수 있다.
  - tryLock(long timeout, TimeUnit unit) 메서드 사용
### 예제 Connection Timout 설정

## 10.2.2 스레드 덤프를 활용한 데드락 분석
- JVM 이 만들어내는 스레드 덤프를 이용하여 도움을 얻을 수 있다.
- Spring actuator thread dump path -> /actuator/threaddump
### 예제 actuator thread dump 분석

## 10.3 그 밖의 활동성 문제점
- 활동성을 떨어뜨리는 주된 원인은 데드락이지만, 그 밖에도 여러 원인들이 있을 수 있다.

## 10.3.1 소모 (Starvation)
- 스레드가 작업을 진행하는 데 꼭 필요한 자원을 영영 할당받지 못하는 경우에 발생한다.
- new Thread().setPriority() -> 우선순위 설정 가능
- 이러한 상태를 일으키는 가장 흔한 원인은 CPU 이다. (예: 우선순위가 낮은 스레드가 우선순위가 높은 스레드에 의해 영영 실행되지 못하는 경우)
1. SJF (Shortest Job First)
2. SRTF (Shortest Remaining Time First)
3. Priority Scheduling (Non-preemptive) 
등등...

## 10.3.2 형편 없는 응답성
- 락을 제대로 관리 못해서 응답성이 떨어질 수 있음
  - 필요 이상의 범위
## 10.3.3 라이브락 (Livelock)
- 메시지 전송 실패 -> 재전송 -> 메시지 전송 실패 -> 재전송
- 계속 실패만하는 로직을 계속 반복하는 상태