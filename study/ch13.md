# 명시적인 락

- **13.1 Lock과 ReentrantLock**
    - 13.1.1 폴링과 시간 제한이 있는 락 확보 방법
    - 13.1.2 인터럽트 걸 수 있는 락 확보 방법
    - 13.1.3 블록을 벗어나는 구조의 락

- **13.2 성능에 대한 고려 사항**
- **13.3 공정성**
- **13.4 synchronized 또는 ReentrantLock 선택**
- **13.5 읽기-쓰기 락**

--- 

# 13.1 Lock과 ReentrantLock

**ReentrantLock 은 Synchronized 에 비하여, 락을 제대로 확보하기 어려운 시점에 훨씬 능동적으로 대처할 수 있다. (p406)**

- Timeout 을 지정하여 유연하게 대처 가능

``` java
public boolean tryLock(long timeout, TimeUnit unit)

LockSupport.parkNanos(this, nanos);
```

하지만 정확한 시간초 뒤에 깨우는게 아니다. 약간의 오차 발생 가능 그래서 루프를 돌면서 확인해야 함

---

**왜 명시적인 락이 필요할까?**

- 대기 상태에 들어가지 않으면서 락을 확보하는 방법이 필요
    - tryLock()
- 락을 확보하는데 시간이 오래 걸릴 수 있는 상황에서, 타임아웃을 지정하여 대기 시간을 제한할 수 있어야 함
    - tryLock(timeout, unit)
- 하지만 finally 블록에서 반드시 해제해야 함

---

## 13.1.1 폴링과 시간 제한이 있는 락 확보 방법

두가지 방식의 핵심은 락을 획득하려는 시도 뒤에 통제권을 얻을 수 있다는 것이다.

- tryLock() : 즉시 반환 -> 폴링 방식으로 활용 가능
- tryLock(timeout, unit) : 지정된 시간 동안 락을 얻기 위해 대기 -> 타임아웃 방식으로 활용 가능

--- 

## 13.1.2 인터럽트 걸 수 있는 락 확보 방법

- lockInterruptibly() : 락을 얻기 위해 대기하는 동안 인터럽트가 걸리면, InterruptedException 발생
- tryLock(timeout, unit) : 지정된 시간 동안 락을 얻기 위해 대기하는 동안 인터럽트가 걸리면, InterruptedException 발생

두 메서드 모두 Thread 가 interrupted 상태인지 확인 후 인터럽트된 상태 일 경우 `acquire` 메서드에서 음수 반환 그리고, 이를 호출한 쓰레드에서 음수 판단 후 예외 발생

왜 쓸까? -> 처음에 Timeout 시간을 정하기 애매하고, 특정 트리거를 받아서 lock 대기를 해제하고 싶을 때?

--- 

## 13.1.3 블록을 벗어나는 구조의 락

---

# 13.4 synchronized 또는 ReentrantLock 선택

| 기능        | synchronized        | Lock                  |
|-----------|---------------------|-----------------------|
| **기본 락**  | `synchronized(obj)` | `lock.lock()`         |
| **인터럽트**  | 불가능                 | `lockInterruptibly()` |
| **타임아웃**  | 불가능                 | `tryLock(time, unit)` |
| **조건 변수** | 1개 (wait/notify)    | 여러 개 (Condition)      |
| **공정성**   | 불공정                 | 공정/불공정 선택             |
| **성능**    | JVM 최적화             | 유연성 높음                |

---

# 13.5 읽기-쓰기 락
