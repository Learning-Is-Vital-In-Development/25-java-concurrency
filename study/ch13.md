# 명시적인 락

- **13.1 Lock과 ReentrantLock**
    - 13.1.1 폴링과 시간 제한이 있는 락 확보 방법
    - 13.1.2 인터럽트 걸 수 있는 락 확보 방법
    - 13.1.3 블록을 벗어나는 구조의 락

- **13.2 성능에 대한 고려 사항**
- **13.3 공정성**
- **13.4 synchronized 또는 ReentrantLock 선택**
- **13.5 읽기-쓰기 락**

--- 

# 13.1 Lock과 ReentrantLock

**ReentrantLock 은 Synchronized 에 비하여, 락을 제대로 확보하기 어려운 시점에 훨씬 능동적으로 대처할 수 있다. (p406)**

- Timeout 을 지정하여 유연하게 대처 가능

``` java
public boolean tryLock(long timeout, TimeUnit unit)

LockSupport.parkNanos(this, nanos);
```

하지만 정확한 시간초 뒤에 깨우는게 아니다. 약간의 오차 발생 가능 그래서 루프를 돌면서 확인해야 함

---

**왜 명시적인 락이 필요할까?**

- 대기 상태에 들어가지 않으면서 락을 확보하는 방법이 필요
    - tryLock()
- 락을 확보하는데 시간이 오래 걸릴 수 있는 상황에서, 타임아웃을 지정하여 대기 시간을 제한할 수 있어야 함
    - tryLock(timeout, unit)
- 하지만 finally 블록에서 반드시 해제해야 함

---

## 13.1.1 폴링과 시간 제한이 있는 락 확보 방법

두가지 방식의 핵심은 락을 획득하려는 시도 뒤에 통제권을 얻을 수 있다는 것이다.

- tryLock() : 즉시 반환 -> 폴링 방식으로 활용 가능
- tryLock(timeout, unit) : 지정된 시간 동안 락을 얻기 위해 대기 -> 타임아웃 방식으로 활용 가능

--- 

## 13.1.2 인터럽트 걸 수 있는 락 확보 방법

- lockInterruptibly() : 락을 얻기 위해 대기하는 동안 인터럽트가 걸리면, InterruptedException 발생
- tryLock(timeout, unit) : 지정된 시간 동안 락을 얻기 위해 대기하는 동안 인터럽트가 걸리면, InterruptedException 발생

두 메서드 모두 Thread 가 interrupted 상태인지 확인 후 인터럽트된 상태 일 경우 `acquire` 메서드에서 음수 반환 그리고, 이를 호출한 쓰레드에서 음수 판단 후 예외 발생

왜 쓸까? -> 처음에 Timeout 시간을 정하기 애매하고, 특정 트리거를 받아서 lock 대기를 해제하고 싶을 때?

--- 

## 13.1.3 블록을 벗어나는 구조의 락

synchronized 는 진입 시 락을 획득하고 블록을 벗어날 때 자동으로 락을 해제하는 구조  
-> 락 해제에 대한 실수를 방지해 준다.

하지만, 복잡한 프로그램에서는 좀 더 유연한 구조의 lock 획득과 해제가 필요하다.  
-> hash collection 같은 경우 여러 개의 해시 블록을 구성하여 각각의 블록마다 락을 유연하게 거는 구조이다.

---

# 13.2 성능에 대한 고려 사항

- 자바 5까지만 해도 성능적 측면에서, ReentrantLock > synchronized 이다. 특히, 스레드 개수가 늘어날 수록 성능차이는 심해진다.
- 자바 6부터 JVM 에서 synchronized 를 최적화 하면서, 두 방식의 성능차이는 거의 없어졌다.
- 교훈: `X 가 Y 보다 더 빠르다` 라는 명제는 그다지 오래 가지 못한다.

---

# 13.3 공정성

---

# 13.4 synchronized 또는 ReentrantLock 선택

| 기능        | synchronized        | Lock                  |
|-----------|---------------------|-----------------------|
| **기본 락**  | `synchronized(obj)` | `lock.lock()`         |
| **인터럽트**  | 불가능                 | `lockInterruptibly()` |
| **타임아웃**  | 불가능                 | `tryLock(time, unit)` |
| **조건 변수** | 1개 (wait/notify)    | 여러 개 (Condition)      |
| **공정성**   | 불공정                 | 공정/불공정 선택             |
| **성능**    | JVM 최적화             | 유연성 높음                |

---

# 13.5 읽기-쓰기 락
