# Virtual Thread

# Overview
가상 스레드는 경량 스레드로, 높은 처리량의 동시 실행 애플리케이션을 작성하는 데 효율적이다. 기존 Java의 Thread 방식은 메모리 제약, OS 제약, Context Switching cost 등의 문제로 인해 확장성에 문제가 있다. thread-per-request 모델의 경우 코드가 직관적이며, 디버깅하기 쉬운 장점이 있는 반면 수천~수만 개의 동시 요청 등의 처리에는 비효율적이다.

마찬가지로 기존의 ThreadPool 방식 또한 스레드 풀 자원 확장의 한계, 스레드가 논리적으로는 놀고 있지만 물리적으로는 점유 중인 비효율적 상태와 같은 문제가 있다.

다른 방법으로 Reactive한 프로그래밍(ex. WebFlux) 같은 방식이 존재하지만, 함수형 프로그래밍으로의 전환(높은 learning curve), 디버깅의 복잡성, 기존 blocking library와의 통합이 어려움 등의 이유로 벽이 높은 상황이다.


이러한 문제개선을 위해 Java에선 JDK21 버전을 통해 정식적으로 도입되었다.

# PlatformThread & VirtualThread
Thread는 **스케줄링 가능한 가장 작은 처리의 단위**이다. 이러한 스레드는 다른 단위들과 동시에 실행되며, 대체적으로 독립적으로 실행된다. Java의 Thread(`java.lang.Thread`)에는 두 가지 종류의 Thread가 존재하며, 각각 `PlatformThread`와 `VirtualThread`이다.

## Thread
먼저 Thread는 위에서 말한 것처럼 스케줄링 가능한 가장 작은 처리 단위이다. 그중 여러가지가 있으며, 작어븨 **고유한 실행 경로**이다.
작은 프로세스이므로 OS가 다른 스레드와 함께 실행하도록 스케줄링할 수 있으며, 이떄 OS가 생성한 프로그램과 메모리 및 자원을 공유하여 여러 스레드가 협력한다.

이처럼 프로세스와 일부 특성을 공유하기 때문에 `경량 프로세스`라고 불리기도 한다. 각 스레드는 단 하나의 프로세스에만 속하며, 멀티스레딩을 지원하는 OS의 경우 하나의 프로세스가 다수의 스레드를 가질 수 있다.

### Thread Type
OS에는 두 가지 유형의 Thread가 존재하며, 이를 각각 **Kernel-level Threads(KLT)** 와 **User-level Threads(ULT)** 라고 부른다.

#### Kernel-level Threads
- 운영체제 논리적 코어와 매핑되는 시스템의 실제 스레드로 커널 영역에서 스레드의 생성과 관리를 수행한다.
- 즉 커널이 생성하는 스레드이며 커널이 직접 관리하는 스레드이다.
- 커널이 각 스레드를 개별적으로 관리하며 **프로세스 내 스레드들이 병렬 수행이 가능**하다.
- 커널이 직접 스레드를 제공하기 때문에 안정성과 시스템 전반에 걸친 스케줄링 우선순위 선정 등 다양한 기능을 제공한다.
- 스레드 중 하나가 block 되더라도 프로세스나 다른 스레드는 계속 작업이 가능하다.
- 커널은 프로세스 단위로 자원을 할당하기 때문에 스레드가 block되면 프로세스도 block되고 프로세스 내 다른 스레드도 block 되는 현상이 발생한다.

#### User-level Threads
- 커널이 생성하는 것이 아닌 사용자 영역에서 라이브러리를 이용해 생성한 스레드이다.
- 커널은 프로세스 내 사용자 스레드를 알지 못한다.
- 스케줄링이나 동기화가 모두 라이브러리에서 진행되기 때문에 커널을 호출하지 않아도 되고 인터럽트 발생 시 오버헤드가 적다.
- 스케줄링이 라이브러리에서 진행되기 때문에 시스템 전반에 걸친 스케줄링 우선순위를 지원할 수 없다.
- 커널은 user-level thread 존재를 모르기 때문에 하나의 프로세스로 인식하게 된다.
- 즉 프로세스 실행을 위한 하나의 kernel-level thread가 여러 개의 user-level thread를 관리하는 Many-to-one 모델이다.
- 따라서 user-level thread가 block 된다면 프로세스도 block 된다.

  <img width="1042" height="440" alt="image" src="https://github.com/user-attachments/assets/dc25984d-001d-408c-a0d8-c15673736f82" />

### Java의 Thread 동작(with OS)
위의 `KLT`, `ULT`의 경우 이론적인 설명이며, Java는 기본적인 이론과는 조금 다르게 동작한다. Java Thread는 유저 수준 스레드지만, 내부적으로 JVM은 커널 스레드를 사용한다. 커널 스레드 풀에 있는 커널 스레드에서 이용할 수 있도록 위임하여, 커널 스레드와 1:1 매핑을 통해 동작하게 된다.

<img width="1280" height="768" alt="image" src="https://github.com/user-attachments/assets/89b7f8bb-abe8-452a-bf2d-9d14cd914056" />


#### JNI
`Java Native Interface`의 약자로, 자바 코드에서 네이티브 코드(하드웨어와 운영체제가 직접 실행할 수 있는 기계어 또는 바이너리 코드를 의미)를 호출하거나, 반대로 네이티브 코드에서 Java 코드를 호출할 수 있게 해주는 프레임워크를 말함.
따라서 자바 코드에서 JNI를 통해 C언어 또는 C++언어로 작성된 코드를 실행할 수 있게 됨.

#### Java가 OS Thread를 사용하는 방법
```java
    void start(ThreadContainer container) {
        synchronized (this) {
            // zero status corresponds to state "NEW".
            if (holder.threadStatus != 0)
                throw new IllegalThreadStateException();

            // bind thread to container
            if (this.container != null)
                throw new IllegalThreadStateException();
            setThreadContainer(container);

            // start thread
            boolean started = false;
            container.onStart(this);  // may throw
            try {
                // scoped values may be inherited
                inheritScopedValueBindings(container);

                start0();
                started = true;
            } finally {
                if (!started) {
                    container.onExit(this);
                }
            }
        }
    }

    private native void start0();
```

여기서 `native` 키워드가 중요하며 이는 이들은 C, C++ 등으로 작성된 메소드로  Native 메소드를 호출 할 때 JNI(Java Native Interface)로 구현되어 작동한다.
결국 여러 java.lang.Thread 객체는 JVM에 존재하는 start0 함수를 JNI를 통해 호출하고, 각 머신 OS에 맞게 설치된 JVM은 커널 스레드를 만들어 실행한다.
이러한 네이티브 메서드 호출은 JVM 내에서 스택과 분리되어 있는 네이티브 메서드 스택을 사용한다.
<img width="2266" height="1214" alt="image" src="https://github.com/user-attachments/assets/e5d73002-bb95-473b-b90d-1db5cb263af7" />

즉 ULT와 KLT아 1:1로 매핑되어 돌아가는 구조이며, 이를 도식화 하면 아래와 같다.

<img width="1896" height="988" alt="image" src="https://github.com/user-attachments/assets/4e6f1d5c-1f34-4f11-a953-4e68af718a3c" />

## Virtual Thread
우선 Java Virtual Thread는 비동기 프로그래밍과 관련된 문제를 해결하기 위해 존재한다. 단순한 조회 쿼리문에 있을 경우 CPU의 유후시간은 약 0.0001% 에 가까운데 이 자체가 CPU에겐 엄청난 수치이다.
고전적인 방법으로 병렬 처리 혹은 많은 스레드를 활용하는 것이 있으나, 이러한 방식이 100% CPU를 바쁘게 유지할 수 있는지는 의문이다. 위 쿼리문을 기준으로 CPU를 100% 바쁘게 가동하기 위해선
약 100만개의 Thread가 필요하다.

Java의 Thread는 실제 운영체제 스레드의 얇은 레퍼이며 이를 커널 스레드 혹은 플랫폼 스레드라고 한다. 그리고 이러한 커널 스레드는 많은 리소스를 필요하며, 처음 생성시 약 2MB가 필요로한다. 위의 예시를 기준으로
100만개의 Thread를 생성하기 위해선 2TB의 용량이 필요하다. 또한 스레드 생성에도 시간이들며 100만개 기준 1000초의 시간이다. 따라서 각 요청에 대해 하나의 스레드를 만드는 솔루션은
초당 요청수를 늘리기위한 방법으론 부적절하다.

실제 이 문제를 개선하기 위한 방법이 두 가지정도 있으며 아래와 같다.(초당 요청수를 증가시키며)
1. 병렬적 처리
   - 현재 커널/플랫폼 스레드보다 비용이 덜 드는 새로운 유형의 스레드를 만듦.
   - 플랫폼 스레드당 두 개의 요청을 수행
2. 비동기 프레임 워크를 사용
   - CompletableFuture API
   - WebFlux 등

다만 비동기 프레임워크의 사용은 유지관리 비용에서 많은 cost가 발생하게 된다. 따라서 비동기 프로그래밍에 의존하지 않고 비용이 덜 드는 스레드만으로 CPU 사용 문제를 해결할 필요성이 있음.

따라서 위에 설명한 예시와 같이 경량형 스레드를 만들필요가 있으며, 플랫폼 스레드보다 1000배는 가벼운 경량 스레드를 만들기로 한다. 이러한 가상 스레드는 풀링할 필요도 없으며, 필요할때 쓰고 쓸모가 없어지면 버리면 되는 구조이다.

운영체제가 사용하는 플랫폼 스레드는 그대로 유지한체 해당 플랫폼 스레드에 여러 작업을 실행시키는 것이 중요하다.(따라서 가상스레드는 플랫폼 스레드 위에서 동작해야 한다.) 

Virtual Thread는 기존 KLT(1) : ULT(1)의 구조가 아닌 KLT(1) : ULT(1) : Virtual Thread(N)의 구조로 사용된다. KLT와 Virtual Thread 사이의 ULT는 플랫폼 스레드라고 한다.

<img width="1716" height="1576" alt="image" src="https://github.com/user-attachments/assets/8dbeb89c-2f44-4e44-bb22-dfaa1edd9e97" />

<img width="1894" height="982" alt="image" src="https://github.com/user-attachments/assets/90600c85-1d65-4351-91c1-6b94d447bd48" />

## PlatformThread & VirtualThread
고전적인 1 Request per 1 Thread 모델에 사용되었던 Platform Thread 는 생성, 사용, Context Switch 하는데에 많은 비용을 요구했기 때문에 스레드가 Blocking 되어 대기상태에 오랜 시간 머무르는것이 성능 저하를 일으키는 원인이었다

가상 스레드는 이 플랫폼 스레드 내부에서 실행되며, 이렇게 플랫폼 스레드가 가상 스레드를 실행해 주는 역할을 할 때는 `캐리어 스레드(carrier thread)`라고한다.


가상 스레드는 총 9개의 상태를 가지고 있으며, 각 상태에 따라 플랫폼 스레드에 mount/unmount 되어 실행된다.
```java
    private static final int NEW      = 0;
    private static final int STARTED  = 1;
    private static final int RUNNABLE = 2;     // runnable-unmounted
    private static final int RUNNING  = 3;     // runnable-mounted
    private static final int PARKING  = 4;
    private static final int PARKED   = 5;     // unmounted
    private static final int PINNED   = 6;     // mounted
    private static final int YIELDING = 7;     // Thread.yield
    private static final int TERMINATED = 99;  // final state
```

플랫폼 스레드에 언마운트/마운트할 때에는 park/unpark 메서드를 사용할 수 있다.
```java
sealed abstract class BaseVirtualThread extends Thread  
        permits VirtualThread, ThreadBuilders.BoundVirtualThread {

    /**
     * Initializes a virtual Thread.
     *
     * @param name thread name, can be null
     * @param characteristics thread characteristics
     * @param bound true when bound to an OS thread
     */
    BaseVirtualThread(String name, int characteristics, boolean bound) {
        super(name, characteristics, bound);
    }

    /**
     * Parks the current virtual thread until the parking permit is available or
     * the thread is interrupted.
     *
     * The behavior of this method when the current thread is not this thread
     * is not defined.
     */
    abstract void park();

    /**
     * Parks current virtual thread up to the given waiting time until the parking
     * permit is available or the thread is interrupted.
     *
     * The behavior of this method when the current thread is not this thread
     * is not defined.
     */
    abstract void parkNanos(long nanos);

    /**
     * Makes available the parking permit to the given this virtual thread.
     */
    abstract void unpark();
}
```

기존에는 자바 스레드가 Blocking되면 매핑된 커널 스레드까지 Blocking되는 구조였으나, 가상 스레드에선 실행 중 Blocking된다면 mount되어 있던 자바 스레드에서 unmount되고, 다른 Virtual Thread가 자바 스레드에 mount되어 실행되는 구조로 실질적으로 CPU를 점유하고 있는
커널 스레드의 경우 Blocking 되지 않는 점이 특징이다.이러한 특징 덕분에, Virtual Thread 사용 시 기존에 사용하던 동기적인 코드 흐름을 그대로 유지할 수 있으면서도, 내부적으론 비동기 방식과 비슷하게 동작하게 되어 Non-Blocking 처리가 가능해져 처리량을 높일 수 있게 된다.
또한 기존 스레드 간의 Context Switching은 커널 레벨에서 발생하지만 Virtual Thread간의 Context Switching은 유저 레벨에서 발생하기 때문에 비용을 절감할 수 있다.

### Virtual Thread 주요 구성 요소

1) **ForkJoinPool**
Virtual Thread들의 static 멤버(즉 모든 Virtual Thread가 공유)로, Virtual Thread들을 스케쥴링하는 스케쥴러 역할을 한다.


2) **Carrier Thread**
Virtual Thread이 mount되어 실행되는 실질적인 자바 스레드이며,  Carrier Thread들은 저마다 하나씩 WorkQueue라 불리는 work-stealing 방식으로 동작하는 큐를 가집니다. 논리적인 관점에서 Carrier Thread는 Virtual Thread와 1 : N의 매핑 관계를 가지며, Carrier Thread와 커널 스레드는 1 : 1의 매핑 관계를 가진다.
※ work-stealing : Carrier Thread들이 자신의 workQueue에 아무 것도 없으면 다른 Carrier Thread의 workQueue에 있는 걸 훔쳐와서 사용하는데, 이를 work-stealing이라고 표현한다.


3) **Continuation**
Virtual Thread가 실행해야 하는 작업과 그 작업에 대한 정보(어디까지 실행했는지 등)을 가지는 객체이다.


4) **runContinuation**
Continuation을 실질적으로 실행시키는 일종의 람다식이다.

### 동작 방식 - Virtual Thread가 실행 중 Blocking될 때 unmount되는 과정
Virtual Thread는 start메서드 호출 시 submitRunContinuation 메서드가 호출되고, 스케쥴러(ForkJoinPool)의 execute 메서드가 호출된다.
```java
    @Override
    void start(ThreadContainer container) {
        if (!compareAndSetState(NEW, STARTED)) {
            throw new IllegalThreadStateException("Already started");
        }

            // 생략
            // submit task to run thread
            submitRunContinuation();
            started = true;
            //생략
    }
```
```java
    private void submitRunContinuation() {
        try {
            scheduler.execute(runContinuation);
        } catch (RejectedExecutionException ree) {
            submitFailed(ree);
            throw ree;
        }
    }
```
그러면 스케쥴러가 적당한 Carrier Thread를 하나 골라 runContinuation을 해당 Carrier Thread의 WorkQueue에 넣어주게된다.
```java
    /**
     * Pushes a submission to the pool, using internal queue if called
     * from ForkJoinWorkerThread, else external queue.
     */
    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty,
                                           ForkJoinTask<T> task) {
        //생략
        q.push(task, this, signalIfEmpty);
        return task;
    }
```
이후 Carrier Thread가 본인의 WorkrQueue에 들어있는 runContiation을 뽑아 실행시키면 Virtual Thread와 Carrier Thread가 mount되고 Virtual Thread가 실행된다.
```java
/**
 * Runs or continues execution of the continuation on the current thread.
 */
private void runContinuation() {
    // 생략
    try {
        cont.run();
    } finally {
        if (cont.isDone()) {
            afterTerminate();
        } else {
            afterYield();
        }
    }
}
```
<img width="1729" height="1544" alt="image" src="https://github.com/user-attachments/assets/f3e59092-7d34-4313-a6ff-c0478b40533c" />

### 동작 방식 - Blocking됐던 Virtual Thread가 다시 재개되는 과정
Blocking상태가 끝나면 내부적으로 unpark() 메서드가 호출되며, 다시 submitRunContinuation이 호출되면서 Carrier Thread의 WorkQueue에 runContinuation필드가 들어간다.
이후 Carrier Thread가 이를 뽑아내서 mount할 때 아까 Heap에 복사해뒀던 스택 프레임을 다시 복구시켜서 중단 지점부터 작업을 재개한다.
```java
    /**
     * Re-enables this virtual thread for scheduling. If the virtual thread was
     * {@link #park() parked} then it will be unblocked, otherwise its next call
     * to {@code park} or {@linkplain #parkNanos(long) parkNanos} is guaranteed
     * not to block.
     * @throws RejectedExecutionException if the scheduler cannot accept a task
     */
    @Override
    @ChangesCurrentThread
    void unpark() {
        Thread currentThread = Thread.currentThread();
        //생략
                    submitRunContinuation();
                }
            } else if (s == PINNED) {
                // unpark carrier thread when pinned.
                synchronized (carrierThreadAccessLock()) {
                    Thread carrier = carrierThread;
                    if (carrier != null && state() == PINNED) {
                        U.unpark(carrier);
                    }
                }
            }
        }
    }
```
```java
    private void submitRunContinuation() {
        try {
            scheduler.execute(runContinuation);
        } catch (RejectedExecutionException ree) {
            submitFailed(ree);
            throw ree;
        }
    }
```
```java
    /**
     * Pushes a submission to the pool, using internal queue if called
     * from ForkJoinWorkerThread, else external queue.
     */
    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty,
                                           ForkJoinTask<T> task) {
        //생략
        q.push(task, this, signalIfEmpty);
        return task;
    }
```

<img width="1709" height="3808" alt="image" src="https://github.com/user-attachments/assets/bb34c732-a09d-401d-be40-61a698a9c62f" />

