## GUI는 왜 단일 스레드로 동작하는가?

GUI 애플리케이션만의 특이한 스레드 문제는 **프로그램이 안정적으로 동작하려면 특정 작업이 반드시 이벤트 스레드에서 실행**돼야 한다는 점임
- 오래 걸리는 작업은 화면 응답을 멈추게 함 → **백그라운드 스레드로 분리 필요**  
- 자료구조가 스레드 안전하지 않음 → GUI 관련 작업은 이벤트 스레드에 제한해 실행해야 함  

### 단일 스레드 서브시스템
- GUI 툴킷은 **GUI 관련 작업이 모두 단일 스레드에서 일어나는 구조**로 구현됨
  - 과거: 메인 이벤트 반복문(main event loop)에서 GUI 이벤트 처리  
  - 최근: **이벤트 처리 전담 스레드**가 큐에서 이벤트를 꺼내 실행하는 **단일 스레드 이벤트 큐 모델** 사용
- 대부분의 GUI 프레임워크가 해당 모델로 이루어짐

### 멀티스레드 GUI의 문제
- 여러 스레드를 쓰려는 시도가 있었지만 **경쟁 조건, 데드락** 문제 발생
- 단일 스레드 이벤트 큐 모델로 정착

#### 데드락 발생 원인
1. **객체 지향 구조와 동기화 문제**
   - GUI 컴포넌트는 양방향 상호작용 과정을 거침
   - 객체를 스레드 안전하도록 동기화하기 위해 락을 배치하다 보면, 순서가 어긋나 데드락 발생

     ```java  
final Object L1 = new Object();
final Object L2 = new Object();

Thread t1 = new Thread(() -> {
    synchronized (L1) {              // 1) L1 획득
        sleep(100);                  // 잠깐 대기
        synchronized (L2) {          // 3) L2 대기
            // do something
        }
    }
});

Thread t2 = new Thread(() -> {
    synchronized (L2) {              // 2) L2 획득
        sleep(100);
        synchronized (L1) {          // 4) L1 대기
            // do something
        }
    }
});```

2. **MVC 패턴**
   - 모델(Model), 뷰(View), 컨트롤러(Controller)가 협업하는 구조는 구현을 단순하게 하지만  
     락 순서를 잘못 배치하기 쉽고, 결과적으로 데드락에 취약해짐

## 스윙의 스레드 한정

모든 스윙 컴포넌트와 데이터 모델 객체는 **이벤트 스레드**에 한정되도록 만들어져 있기 때문에 **항상 이벤트 스레드 내부에서만 사용**해야 함
이 덕분에 GUI 객체는 스레드 안정성을 확보하지만 **GUI 관련 객체를 이벤트 스레드 외부에서는 절대 건드려서는 안 됨**

### 단일 스레드 규칙
- 스윙 컴포넌트와 모델 객체는 **이벤트 스레드 내부에서만** 생성하고, 변경하고, 사용할 수 있음
- 스윙 내부 메소드 가운데 몇 가지는 **예외적으로 이벤트 스레드 외부에서도** 얼마든지 호출할 수 있으며, 이런 메소드는 **항상 스레드 안전**하게 외부에서 호출할 수 있음

### 이벤트 스레드 외부에서도 호출할 수 있는 메소드
- `SwingUtilities.isEventDispatchThread` : 현재 스레드가 이벤트 스레드인지를 알려주는 메소드
- `SwingUtilities.invokeLater` : `Runnable`을 등록해 **이벤트 스레드에서 실행**되도록 해줌
- `SwingUtilities.invokeAndWait` : `Runnable`을 등록해 **이벤트 스레드에서 실행**되도록 하며, **해당 작업이 끝날 때까지 대기함**

### 이벤트 큐 관련
- 화면을 다시 그리거나 재정비하는 요청을 이벤트 큐에 쌓는 메소드
- 이벤트 리스너 추가/제거 메소드
  위 두 메소드 또한 이벤트 스레드 외부에서도 호출 가능함
  단, **리스너의 메소드 호출은 이벤트 스레드에서만** 이루어짐

### 이벤트 스레드의 성격
- 스윙 이벤트 스레드는 이벤트 큐에 쌓여 있는 작업을 순차적으로 처리하는 **단일 스레드 Executor**
- **순차적 단일 스레드 실행** 방법 :
  - 각 작업이 **짧게 실행** 되며,
  - 스케줄된 상황을 **예측할 필요가 없고**,
  - 작업을 **동시에 실행시킬 필요가 없는** 경우에 쓸모 있음
 
 ## 짧게 실행되는 GUI 작업

GUI 애플리케이션에서는 이벤트 스레드에서 이벤트가 시작돼 애플리케이션에 만들어져 있는 리스너에게 전파됨  
리스너가 이벤트를 받으면 화면에 뭔가를 표시하는 객체를 사용해 동작함

처리할 작업이 **금방 처리되는 작업이면서 GUI 객체에서만 실행하는 작업**이라고 한다면,  
모든 작업을 이벤트 스레드 내부에서 처리하도록 해도 별 문제가 없고, 프로그램은 항상 예상했던 대로 동작함

스윙에서는 대부분의 화면 표시 객체가 두 개의 부분으로 나뉨 - 뷰와 모델
- 화면에 표시돼야 할 실제 데이터는 **모델**에 보관
- 모델에 들어 있는 데이터를 화면에 어떻게 표시해야 할지는 **뷰**에서 결정함 

모델에서 갖고 있는 데이터가 변경되면 **데이터 변경 이벤트**를 발생시키게 되고, 이를 뷰의 리스너가 받음.  
뷰는 모델에서 변경된 내역을 받아온 다음, 해당 내용을 화면에 표시함
**제어권은 이벤트 스레드를 떠난 적이 없음**

## 장시간 실행되는 GUI 작업

장시간 실행되는 GUI 작업은 이벤트 스레드와 달리 **독립된 스레드**에서 실행하도록 하면 됨
즉, Executor를 직접 생성해 두고 시간이 많이 걸리는 작업을 실행시키면 됨

- `newCachedThreadPool` 메소드로 생성한 Executor 사용
  - GUI 애플리케이션에서 시간이 오래 걸릴 작업을 기계적으로 대량 생성하는 일은 거의 없음
  - 스레드 풀의 크기가 무한정 늘어날 가능성은 거의 없음

    ```java
     button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                button.setEnabled(false);
                label.setText("busy");
                exec.execute(new Runnable() {
                    public void run() {
                        try {
                            /* Do big computation */
                        } finally {
                            GuiExecutor.instance().execute(new Runnable() {
                                public void run() {
                                    button.setEnabled(true);
                                    label.setText("idle");
                                }
                            });
                        }
                    }
                });
            }
        });
    }```
    
- 장시간 실행된 작업이 종료되면, 사용자 인터페이스에 종료 결과를 반영하는 기능의 작업을 생성해 **이벤트 스레드에서 실행되도록** 해야 함

즉, GUI 애플리케이션에서 오래 걸리는 작업을 처리해야 할 때는 **스레드를 넘어다니는 방식** 을 자주 사용함


### 작업 중단(Future)

작업 중단은 Future를 활용하면 간단하게 구현 가능함
Future를 구현한 클래스는 작업이 특정 스레드에서 시작됐을 경우 **해당 스레드에 인터럽트**를 걸게 돼 있음

## 데이터 공유 모델

### 스레드 안전한 데이터 모델
모델의 내용이 업데이트 됐을 때 이벤트를 발생시키고 하며, 이런 이벤트를 받아 처리하도록 하면
데이터가 바뀌었을 때 변경된 정보를 화면에 즉시 표시할 수 있음

### 분할 데이터 모델
GUI입장에서 TableModel이나 TreeMoel과 같은 스윙 내부의 데이터 모델 클래스는 화면에 표시할 데이터를 저장하는 공식 저장소와 같음
-> 애플리케이션이 관리하는 다른 데이터 저장소에 대한 '뷰'에 불과하기도 함
- 분할 데이터 모델 : 화면 표시 부분과 애플리케이션 부분의 데이터 모델을 구분해 사용하는 모양

## 다른 형태의 단일 스레드 서브시스템



    


     
